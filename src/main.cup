import java_cup.runtime.*;
import java.util.Vector;
import java.io.*;
import java.util.*;

action code {:

:}

terminal PRG, STARTPRG, ENDPRG, CONSTANT, SEMICOLON, STARTFUNC, ENDFUNC, OPENPARENT;
terminal CLOSEPARENT, COMMA, EQUAL, DOUBLEPOINTS, OPENBRACK, CLOSEBRACK;
terminal READ, WRITE, RETURN, IF, THEN, ELSE, ENDIF, WHILE, DO, ENDWHILE;
terminal FOR, FROM, TO, ENDFOR, TRUE, FALSE,  PLUS, MINUS, TIMES, DIVIDE;
terminal EQUALS, DIFF, INF, INFEQUAL, SUP, SUPEQUAL, AND, OR, TILDA, NOT;

terminal String IDENT, STRINGCONST, TINTEGER, TBOOLEAN;
terminal int INTEGERCONST;

// Non terminal rules that return a RESULT value
non terminal DeclarationProgramme program, header;
non terminal Bloc declar_lst, body;
non terminal ArrayList<Instruction> instr_lst, declars;
non terminal Instruction declar;
non terminal DeclarationVariable declar_var;
non terminal DeclarationConstant declar_const;
non terminal Expression expr, access, operand;
non terminal for_instr;
non terminal while_instr;
non terminal return_instr;
non terminal cond_instr;
non terminal Ecrire write_instr;
non terminal read_instr;
non terminal Instruction instr;
non terminal Affectation assign;
non terminal index;
non terminal Unaire op_una;
non terminal Binaire op_bin;

non terminal ArrayList<Idf> l_ident;
non terminal Type type;
non terminal TypeBase typebase;

// Precedences
precedence left PLUS, MINUS, TIMES, DIVIDE, EQUALS, DIFF;
precedence left INF, SUP, INFEQUAL, SUPEQUAL, AND, OR, DOUBLEPOINTS;
precedence right TILDA, NOT;

program           ::= header:p declar_lst:decralations STARTPRG body:instructions ENDPRG
                    {:
                      p.setDeclarations(decralations);
                      p.setInstructions(instructions);
                      System.out.println("ok, c'est good !!!!"); 
                      RESULT = p;
                    :};
header            ::= PRG IDENT:id {: RESULT = new DeclarationProgramme(new Idf(id, "", idleft, idright), "", idleft, idright); :};
declar_lst        ::= declars:decralations {: RESULT = new Bloc(decralations, "", decralationsleft, decralationsright); :};
declars           ::= {: RESULT = new ArrayList(); :}
                      | declars:declarationList declar:declaration
                      {: 
                        ArrayList<Instruction> declarations = new ArrayList<Instruction>(declarationList);
                        declarations.add(declaration);
                        RESULT = declarations;
                      :};
declar            ::= declar_var:d      {: RESULT = d; :}
                      | declar_const:d  {: RESULT = d; :};
declar_var        ::= type:t l_ident:idfs SEMICOLON
                      {:
                        RESULT = new DeclarationVariable(t, idfs, "", 0, 0);
                      :};
l_ident           ::= IDENT:id {: RESULT = new ArrayList<Idf>(List.of(new Idf(id, "", idleft, idright))); :}
                      | l_ident:idfs COMMA IDENT:id {:  idfs.add(new Idf(id, "", idleft, idright)); :};
type              ::= typebase:t {: RESULT = t;  :};
typebase          ::= TINTEGER   {: RESULT = new Entier(); :}
                      | TBOOLEAN {: RESULT = new Booleen(); :};
declar_const      ::= CONSTANT type:t IDENT EQUAL expr:e SEMICOLON
                      {:
                        RESULT = new DeclarationConstant(t, e, "", 0, 0);
                      :};
expr              ::= expr:left op_bin:op expr:right
                      {:
                        // build binary expression
                        op.lierGauche(left);
                        op.lierDroit(right);
                        RESULT = op;  
                      :}
                      | op_una:op expr:exp
                      {:
                        // build unary expression
                        op.lier(exp);
                        RESULT = op;
                      :}
                      | OPENPARENT expr CLOSEPARENT {:   :}
                      | operand:operand             {:  RESULT = operand;  :};
op_bin            ::= PLUS:o       {: RESULT = new Addition("", oleft, oright); :}
                      | MINUS:o    {: RESULT = new Soustraction("", oleft, oright); :}
                      | TIMES:o    {: RESULT = new Produit("", oleft, oright); :}
                      | DIVIDE:o   {: RESULT = new Division("", oleft, oright); :}
                      | EQUALS:o   {: RESULT = new Egal("", oleft, oright); :} 
                      | DIFF:o     {: RESULT = new Diff("", oleft, oright); :}
                      | INF:o      {: RESULT = new Inferieur("", oleft, oright); :}
                      | SUP:o      {: RESULT = new Superieur("", oleft, oright); :}
                      | INFEQUAL:o {: RESULT = new InfEgal("", oleft, oright); :}
                      | SUPEQUAL:o {: RESULT = new SupEgal("", oleft, oright); :}
                      | AND:o      {: RESULT = new Et("", oleft, oright); :}
                      | OR:o       {: RESULT = new Ou("", oleft, oright); :};
op_una            ::= TILDA:o      {: RESULT = new Tilda("", oleft, oright);  :}
                      | NOT:o      {: RESULT = new Non("", oleft, oright); :}
                      | MINUS:o    {: RESULT = new Moins("", oleft, oright);  :};
operand           ::= access:access       {: RESULT = access; :}
                      | INTEGERCONST:ib   {: RESULT = new Nombre(ib, "", ibleft, ibright); :}
                      | TRUE:ib           {: RESULT = new Vrai("", ibleft, ibright); :}
                      | FALSE:ib          {: RESULT = new Faux("", ibleft, ibright); :};
access            ::= IDENT:id   {: RESULT = new Idf(id, "", idleft, idright); :};
body              ::= instr_lst:instructions {: RESULT = new Bloc(instructions, "", instructionsleft, instructionsright); :};
instr_lst         ::= {: RESULT = new ArrayList(); :}
                      | instr_lst:instructionList instr:instruction
                      {:
                        ArrayList<Instruction> instructions = new ArrayList<Instruction>(instructionList);
                        instructions.add(instruction);
                        RESULT = instructions;
                      :};
instr             ::= assign:instr                  {: RESULT = instr; :}
                      | write_instr:instr           {: RESULT = instr; :}
                      | read_instr                  {:  :}
                      | cond_instr                  {:  :}
                      | while_instr                 {:  :}
                      | for_instr                   {:  :};
assign            ::= access:dest EQUAL:e expr:src SEMICOLON
                      {:
                        RESULT = new Affectation(dest, src, "", eleft, eright);
                      :};

write_instr       ::= WRITE expr:e SEMICOLON
                      {:
                        RESULT = new Ecrire(e, "", eleft, eright);
                      :}
                      | WRITE STRINGCONST:s SEMICOLON
                      {:
                        Chaine c = new Chaine(s, "", sleft, sright);
                        RESULT = new Ecrire(c, "", sleft, sright);
                      :};

read_instr        ::= READ IDENT SEMICOLON   {:   :};
cond_instr        ::= IF expr THEN body ELSE body ENDIF {:   :}
                      | IF expr THEN body ENDIF {:   :};
while_instr       ::= WHILE expr DO body ENDWHILE {:   :};
for_instr         ::= FOR IDENT FROM expr TO expr DO body ENDFOR {:   :};
